using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Net.NetworkInformation;
using System.Runtime.InteropServices;
using System.Threading;
using System.Windows.Forms;
using Newtonsoft.Json;
using NVRRecordingSystem;

namespace FfplayTest
{
    public partial class frmDisplayScreen : Form
    {
        // ============================
        // Globals loaded ONLY from JSON
        // ============================
        private string _recordingRoot;
        private int _segmentSeconds;
        private int _ffmpegThreads;
        private string _rtspTransport;
        private string _fileNamePattern;
        private long _minFreeSpaceMb;
        private int _retentionDays;
        private int _logRetentionDays;
        private string _logRoot;

        private string _ffmpegExePath;
        private string _configPath;

        // Stop flag for watchdog / maintenance / cameras
        private volatile bool _stopRequested = false;

        // Ensure JSON / config error shows only once
        private static bool _jsonErrorAlreadyShown = false;

        // Locks
        private static readonly object _logLock = new object();

        // Cameras loaded from JSON
        private readonly List<CameraRuntime> _cameras = new List<CameraRuntime>();

        // Grid rows
        private readonly BindingList<GridRow> _rows = new BindingList<GridRow>();

        // Watchdog
        private System.Windows.Forms.Timer _watchdogTimer;
        private bool _watchdogBusy = false;

        // Maintenance
        private System.Windows.Forms.Timer _maintenanceTimer;
        private bool _maintenanceBusy = false;

        private bool _configOk = false;

        [DllImport("user32.dll", SetLastError = true)]
        private static extern bool MoveWindow(IntPtr hWnd, int X, int Y, int nWidth, int nHeight, bool bRepaint);

        [DllImport("user32.dll")]
        private static extern IntPtr SetParent(IntPtr hWndChild, IntPtr hWndNewParent);

        public frmDisplayScreen()
        {
            InitializeComponent();

            // Bind grid
            grdProcessDisplay.AutoGenerateColumns = true;
            grdProcessDisplay.DataSource = _rows;

            // Paths
            _configPath = Path.Combine(AppDomain.CurrentDomain.BaseDirectory, "nvrsettings.json");
            _ffmpegExePath = Path.Combine(AppDomain.CurrentDomain.BaseDirectory, "ffmpeg.exe");

            // Load JSON config only once (or exit)
            LoadSettingsOrExitOnce();
            if (!_configOk)
                return;

            // Adjust headers if columns auto-generated by property names
            SetHeader(nameof(GridRow.CameraName), "Camera");
            SetHeader(nameof(GridRow.Pid), "PID");
            SetHeader(nameof(GridRow.Status), "Status");
            SetHeader(nameof(GridRow.LastError), "Last Error");
            SetHeader(nameof(GridRow.LastStart), "Last Start");

            // Initialize grid rows for each camera as "Stopped"
            foreach (var cam in _cameras)
            {
                UpsertRow(cam, null, "Stopped", "", updateStartTime: false);
            }

            // Watchdog timer (30s)
            _watchdogTimer = new System.Windows.Forms.Timer();
            _watchdogTimer.Interval = 30000;
            _watchdogTimer.Tick += WatchdogTimer_Tick;

            // Maintenance timer (1 hour)
            _maintenanceTimer = new System.Windows.Forms.Timer();
            _maintenanceTimer.Interval = 60 * 60 * 1000;
            _maintenanceTimer.Tick += MaintenanceTimer_Tick;
        }

        private void Form1_Load(object sender, EventArgs e)
        {
        }

        private void SetHeader(string colName, string header)
        {
            if (grdProcessDisplay.Columns.Contains(colName))
                grdProcessDisplay.Columns[colName].HeaderText = header;
        }

        // ============================
        // JSON Models
        // ============================
        private class AppSettings
        {
            public string RecordingRoot { get; set; }
            public int? SegmentSeconds { get; set; }
            public int? FFmpegThreads { get; set; }
            public string RtspTransport { get; set; }
            public string FileNamePattern { get; set; }
            public long? MinFreeSpaceMb { get; set; }
            public int? RetentionDays { get; set; }
            public int? LogRetentionDays { get; set; }
            public string LogRoot { get; set; }

            public List<CameraSettings> Cameras { get; set; }
        }

        private class CameraSettings
        {
            public string Name { get; set; }
            public string IpAddress { get; set; }
            public string FolderName { get; set; }
            public string Tag { get; set; }

            // Split RTSP fields
            public string RtspHost { get; set; }
            public int? RtspPort { get; set; }
            public string RtspPath { get; set; }
            public string RtspQuery { get; set; }

            public string Username { get; set; }
            public string Password { get; set; }     // e.g., "data(at)(hash)4"

            // Optional full RTSP URL (fallback)
            public string RtspUrl { get; set; }
        }

        // ============================
        // Runtime models
        // ============================
        private sealed class CameraRuntime
        {
            public string Name { get; set; }
            public string Tag { get; set; }
            public string IpAddress { get; set; }
            public string Folder { get; set; }
            public string RtspUrl { get; set; }

            public Process Proc { get; set; }

            public int FailCount { get; set; }
            public DateTime LastFailUtc { get; set; }
            public DateTime NextAllowedStartUtc { get; set; }

            public string LastErrorLine { get; set; }
        }

        private sealed class GridRow
        {
            public string CameraName { get; set; }
            public string Pid { get; set; }
            public string Status { get; set; }
            public string LastError { get; set; }
            public string LastStart { get; set; }
        }

        // ============================
        // JSON Load (show once & exit)
        // ============================
        private void LoadSettingsOrExitOnce()
        {
            try
            {
                // JSON missing
                if (!File.Exists(_configPath))
                {
                    ShowErrorOnceAndExit(
                        $"Configuration file 'nvrsettings.json' is missing.\n\nExpected:\n{_configPath}");
                    return;
                }

                // ffmpeg.exe missing
                if (!File.Exists(_ffmpegExePath))
                {
                    ShowErrorOnceAndExit(
                        $"ffmpeg.exe is missing.\n\nExpected:\n{_ffmpegExePath}");
                    return;
                }

                // Read JSON
                string json = File.ReadAllText(_configPath);
                var settings = JsonConvert.DeserializeObject<AppSettings>(json);
                if (settings == null)
                {
                    ShowErrorOnceAndExit("nvrsettings.json is invalid or empty.");
                    return;
                }

                // Validate global settings
                string missing = "";
                if (string.IsNullOrWhiteSpace(settings.RecordingRoot)) missing += "RecordingRoot\n";
                if (!settings.SegmentSeconds.HasValue || settings.SegmentSeconds.Value <= 0) missing += "SegmentSeconds\n";
                if (!settings.FFmpegThreads.HasValue || settings.FFmpegThreads.Value <= 0) missing += "FFmpegThreads\n";
                if (string.IsNullOrWhiteSpace(settings.RtspTransport)) missing += "RtspTransport\n";
                if (string.IsNullOrWhiteSpace(settings.FileNamePattern)) missing += "FileNamePattern\n";
                if (!settings.MinFreeSpaceMb.HasValue || settings.MinFreeSpaceMb.Value <= 0) missing += "MinFreeSpaceMb\n";
                if (!settings.RetentionDays.HasValue || settings.RetentionDays.Value <= 0) missing += "RetentionDays\n";
                if (!settings.LogRetentionDays.HasValue || settings.LogRetentionDays.Value <= 0) missing += "LogRetentionDays\n";
                if (string.IsNullOrWhiteSpace(settings.LogRoot)) missing += "LogRoot\n";

                if (!string.IsNullOrEmpty(missing))
                {
                    ShowErrorOnceAndExit(
                        "Missing or invalid global settings in nvrsettings.json:\n\n" + missing);
                    return;
                }

                if (settings.Cameras == null || settings.Cameras.Count == 0)
                {
                    ShowErrorOnceAndExit("No cameras defined in nvrsettings.json.");
                    return;
                }

                // Assign global values
                _recordingRoot = SafeToken(settings.RecordingRoot);
                _segmentSeconds = settings.SegmentSeconds.Value;
                _ffmpegThreads = settings.FFmpegThreads.Value;
                _rtspTransport = SafeToken(settings.RtspTransport);
                _fileNamePattern = SafeToken(settings.FileNamePattern);
                _minFreeSpaceMb = settings.MinFreeSpaceMb.Value;
                _retentionDays = settings.RetentionDays.Value;
                _logRetentionDays = settings.LogRetentionDays.Value;
                _logRoot = SafeToken(settings.LogRoot);

                Directory.CreateDirectory(_logRoot);

                // Load cameras
                _cameras.Clear();
                foreach (var c in settings.Cameras)
                {
                    if (string.IsNullOrWhiteSpace(c.Name))
                        continue;

                    string folderName = string.IsNullOrWhiteSpace(c.FolderName)
                        ? SafeFolderNameFromCameraName(c.Name)
                        : SafeToken(c.FolderName);

                    string tag = string.IsNullOrWhiteSpace(c.Tag)
                        ? SafeFolderNameFromCameraName(c.Name)
                        : SafeToken(c.Tag);

                    string rtsp = BuildRtspUrl(c);
                    if (string.IsNullOrWhiteSpace(rtsp))
                    {
                        LogLine($"Skipping camera '{c.Name}' because RTSP URL could not be built.");
                        continue;
                    }

                    _cameras.Add(new CameraRuntime
                    {
                        Name = SafeToken(c.Name),
                        Tag = tag,
                        IpAddress = SafeToken(c.IpAddress),
                        Folder = Path.Combine(_recordingRoot, folderName),
                        RtspUrl = rtsp,
                        FailCount = 0,
                        LastFailUtc = DateTime.MinValue,
                        NextAllowedStartUtc = DateTime.MinValue,
                        LastErrorLine = ""
                    });
                }

                if (_cameras.Count == 0)
                {
                    ShowErrorOnceAndExit("No valid cameras found in nvrsettings.json.");
                    return;
                }

                LogLine($"Loaded {_cameras.Count} camera(s). ffmpeg: {_ffmpegExePath}");
                _configOk = true;
            }
            catch (Exception ex)
            {
                ShowErrorOnceAndExit("Error loading nvrsettings.json:\n\n" + ex.Message);
            }
        }

        private void ShowErrorOnceAndExit(string msg)
        {
            if (_jsonErrorAlreadyShown) return;
            _jsonErrorAlreadyShown = true;

            try
            {
                MessageBox.Show(msg, "Configuration Error", MessageBoxButtons.OK, MessageBoxIcon.Error);
            }
            finally
            {
                try { Close(); } catch { }
                Environment.Exit(1);
            }
        }

        // ============================
        // Utility: sanitize tokens
        // ============================
        private static string SafeToken(string s)
        {
            return (s ?? "")
                .Replace("\u2013", "-")  // en dash
                .Replace("\u2014", "-")  // em dash
                .Replace("\u00A0", " ")  // nbsp
                .Trim();
        }

        private static string DecodeReadable(string s)
        {
            if (string.IsNullOrEmpty(s)) return s;

            return s
                .Replace("(at)", "@").Replace("[at]", "@").Replace("{at}", "@")
                .Replace("(hash)", "#")
                .Replace("(bang)", "!")
                .Replace("(dollar)", "$")
                .Replace("(percent)", "%")
                .Replace("(and)", "&");
        }

        private static string SafeFolderNameFromCameraName(string name)
        {
            var invalid = Path.GetInvalidFileNameChars();
            var cleaned = new string((name ?? "").Where(ch => !invalid.Contains(ch)).ToArray());
            return cleaned.Replace(" ", "");
        }

        private static string Quote(string s)
        {
            if (string.IsNullOrEmpty(s)) return "\"\"";
            return "\"" + s.Replace("\"", "\\\"") + "\"";
        }

        // ============================
        // RTSP URL builder
        // ============================
        private static string BuildRtspUrl(CameraSettings c)
        {
            // If full URL is provided, just clean and return
            if (!string.IsNullOrWhiteSpace(c.RtspUrl))
                return SafeToken(c.RtspUrl);

            if (string.IsNullOrWhiteSpace(c.RtspHost))
                return null;

            string host = SafeToken(c.RtspHost);
            int port = c.RtspPort ?? 554;

            string path = SafeToken(c.RtspPath);
            if (!string.IsNullOrEmpty(path) && !path.StartsWith("/"))
                path = "/" + path;

            string query = SafeToken(c.RtspQuery);
            if (!string.IsNullOrEmpty(query) && !query.StartsWith("?"))
                query = "?" + query;

            string user = SafeToken(c.Username);
            string pass = DecodeReadable(SafeToken(c.Password)); // convert data(at)(hash)4 -> data@#4

            if (string.IsNullOrWhiteSpace(user))
                return $"rtsp://{host}:{port}{path}{query}";

            // URL-encode user/pass (handles @,#,! etc)
            string userEnc = Uri.EscapeDataString(user);
            string passEnc = Uri.EscapeDataString(pass);

            return $"rtsp://{userEnc}:{passEnc}@{host}:{port}{path}{query}";
        }

        // ============================
        // Logging
        // ============================
        private void LogLine(string text)
        {
            lock (_logLock)
            {
                try
                {
                    Directory.CreateDirectory(_logRoot);
                    File.AppendAllLines(Path.Combine(_logRoot, "CameraLog.txt"),
                        new[] { $"{DateTime.Now:yyyy-MM-dd HH:mm:ss} - {text}" });
                }
                catch
                {
                }
            }
        }

        private void LogFfmpeg(CameraRuntime cam, string line)
        {
            if (string.IsNullOrWhiteSpace(line))
                return;

            lock (_logLock)
            {
                try
                {
                    Directory.CreateDirectory(_logRoot);
                    var file = Path.Combine(_logRoot, $"ffmpeg_{cam.Tag}.log");
                    File.AppendAllLines(file,
                        new[] { $"{DateTime.Now:yyyy-MM-dd HH:mm:ss} - {line}" });
                }
                catch
                {
                }
            }
        }

        // ============================
        // Disk space check
        // ============================
        private bool HasEnoughDiskSpace()
        {
            try
            {
                var root = Path.GetPathRoot(_recordingRoot);
                if (string.IsNullOrEmpty(root)) return true;

                var di = new DriveInfo(root);
                long freeMb = di.AvailableFreeSpace / (1024 * 1024);

                if (freeMb < _minFreeSpaceMb)
                {
                    LogLine($"LOW DISK SPACE {root}: {freeMb}MB free, need at least {_minFreeSpaceMb}MB");
                    return false;
                }

                return true;
            }
            catch (Exception ex)
            {
                LogLine($"Disk check failed: {ex.Message} (assuming OK)");
                return true;
            }
        }

        // ============================
        // FFmpeg args (original working style)
        // ============================
        private string BuildFfmpegArgs(CameraRuntime cam)
        {
            // Ensure folder exists
            Directory.CreateDirectory(cam.Folder);

            // Clean transport
            string rtspTransport = SafeToken(_rtspTransport);
            if (!string.Equals(rtspTransport, "tcp", StringComparison.OrdinalIgnoreCase) &&
                !string.Equals(rtspTransport, "udp", StringComparison.OrdinalIgnoreCase))
            {
                rtspTransport = "tcp";
            }

            // Output file pattern
            string outputFile = Path.Combine(cam.Folder, _fileNamePattern);

            // EXACT style of your old working code:
            // -rtsp_transport tcp -i "rtsp://..." -threads 3 -vcodec copy
            // -f segment -strftime 1 -segment_format mp4 -segment_time 300 "out%Y-...mp4"
            return
                $"-rtsp_transport {rtspTransport} " +
                $"-i {Quote(cam.RtspUrl)} " +
                $"-threads {_ffmpegThreads} " +
                "-vcodec copy " +
                "-f segment " +
                "-strftime 1 " +
                "-segment_format mp4 " +
                $"-segment_time {_segmentSeconds} " +
                Quote(outputFile);
        }

        private int? SafePid(Process p)
        {
            try { return p?.Id; } catch { return null; }
        }

        private void StartCamera(CameraRuntime cam, string reason)
        {
            if (_stopRequested)
                return;

            // Backoff / cooldown
            if (DateTime.UtcNow < cam.NextAllowedStartUtc)
            {
                UpsertRow(cam, null, "Cooldown", cam.LastErrorLine, updateStartTime: false);
                return;
            }

            // Disk space
            if (!HasEnoughDiskSpace())
            {
                cam.FailCount++;
                cam.LastFailUtc = DateTime.UtcNow;
                cam.LastErrorLine = "Low disk space";
                cam.NextAllowedStartUtc = DateTime.UtcNow.AddMinutes(2);
                UpsertRow(cam, null, "Error (Disk Space)", cam.LastErrorLine, updateStartTime: false);
                return;
            }

            // Ping if IP present
            if (!string.IsNullOrWhiteSpace(cam.IpAddress))
            {
                bool pingable = false;
                try
                {
                    using (var ping = new Ping())
                    {
                        var reply = ping.Send(cam.IpAddress, 2000);
                        pingable = reply != null && reply.Status == IPStatus.Success;
                    }
                }
                catch
                {
                    pingable = false;
                }

                if (!pingable)
                {
                    cam.FailCount++;
                    cam.LastFailUtc = DateTime.UtcNow;
                    cam.LastErrorLine = "Ping failed";
                    cam.NextAllowedStartUtc = DateTime.UtcNow.AddSeconds(30);
                    UpsertRow(cam, null, "No Ping", cam.LastErrorLine, updateStartTime: false);
                    return;
                }
            }

            // Stop any previous process
            StopCamera(cam);

            string args = BuildFfmpegArgs(cam);
            LogLine($"START [{cam.Name}] reason={reason}");
            LogFfmpeg(cam, $"CMD: {_ffmpegExePath} {args}");

            var p = new Process
            {
                StartInfo =
                {
                    FileName = _ffmpegExePath,
                    Arguments = args,
                    CreateNoWindow = true,
                    RedirectStandardOutput = false,
                    RedirectStandardError = true,
                    UseShellExecute = false,
                    WorkingDirectory = AppDomain.CurrentDomain.BaseDirectory
                },
                EnableRaisingEvents = true
            };

            cam.LastErrorLine = "";

            p.ErrorDataReceived += (o, e) =>
            {
                if (string.IsNullOrWhiteSpace(e.Data))
                    return;

                cam.LastErrorLine = e.Data.Trim();
                LogFfmpeg(cam, e.Data);
                UpsertRow(cam, SafePid(p), "Running", cam.LastErrorLine, updateStartTime: false);
            };

            p.Exited += (s, e) =>
            {
                int code = 0;
                try { code = p.ExitCode; } catch { }

                cam.Proc = null;
                cam.FailCount++;
                cam.LastFailUtc = DateTime.UtcNow;

                if (string.IsNullOrWhiteSpace(cam.LastErrorLine))
                    cam.LastErrorLine = $"ExitCode={code}";

                int backoffSec = Math.Min(10 + cam.FailCount * 10, 180);
                cam.NextAllowedStartUtc = DateTime.UtcNow.AddSeconds(backoffSec);

                LogLine($"[{cam.Name}] exited code={code} backoff={backoffSec}s lastErr='{cam.LastErrorLine}'");
                UpsertRow(cam, null, $"Exited ({code})", cam.LastErrorLine, updateStartTime: false);

                try { p.Dispose(); } catch { }
            };

            try
            {
                p.Start();
                cam.Proc = p;
                cam.FailCount = 0;
                cam.NextAllowedStartUtc = DateTime.MinValue;

                UpsertRow(cam, SafePid(p), "Running", "", updateStartTime: true);
                p.BeginErrorReadLine();
            }
            catch (Exception exStart)
            {
                cam.Proc = null;
                cam.FailCount++;
                cam.LastFailUtc = DateTime.UtcNow;
                cam.LastErrorLine = exStart.Message;
                cam.NextAllowedStartUtc = DateTime.UtcNow.AddSeconds(30);

                LogLine($"START FAIL [{cam.Name}] {exStart.Message}");
                UpsertRow(cam, null, "Error (Start)", cam.LastErrorLine, updateStartTime: false);

                try { p.Dispose(); } catch { }
            }
        }

        private void StopCamera(CameraRuntime cam)
        {
            var p = cam.Proc;
            if (p == null) return;

            try
            {
                bool canKill = false;
                try { canKill = !p.HasExited; } catch { canKill = false; }

                if (canKill)
                {
                    p.Kill();
                    p.WaitForExit(1500);
                }
            }
            catch
            {
            }
            finally
            {
                try { p.Dispose(); } catch { }
                cam.Proc = null;
            }
        }

        // ============================
        // Grid helpers
        // ============================
        private void UpsertRow(CameraRuntime cam, int? pid, string status, string lastError, bool updateStartTime)
        {
            if (grdProcessDisplay.InvokeRequired)
            {
                grdProcessDisplay.BeginInvoke(new Action(() =>
                    UpsertRowInternal(cam, pid, status, lastError, updateStartTime)));
                return;
            }

            UpsertRowInternal(cam, pid, status, lastError, updateStartTime);
        }

        private void UpsertRowInternal(CameraRuntime cam, int? pid, string status, string lastError, bool updateStartTime)
        {
            var existing = _rows.FirstOrDefault(r => r.CameraName == cam.Name);

            string lastStart = existing?.LastStart ?? "";
            if (updateStartTime)
                lastStart = DateTime.Now.ToString("yyyy-MM-dd HH:mm:ss");

            var row = new GridRow
            {
                CameraName = cam.Name,
                Pid = pid.HasValue ? pid.Value.ToString() : (existing?.Pid ?? ""),
                Status = status ?? "",
                LastError = lastError ?? "",
                LastStart = lastStart
            };

            if (existing == null)
                _rows.Add(row);
            else
                _rows[_rows.IndexOf(existing)] = row;
        }

        // ============================
        // Watchdog
        // ============================
        private void WatchdogTimer_Tick(object sender, EventArgs e)
        {
            if (_watchdogBusy) return;
            _watchdogBusy = true;

            ThreadPool.QueueUserWorkItem(_ =>
            {
                try
                {
                    if (_stopRequested) return;

                    foreach (var cam in _cameras)
                    {
                        if (_stopRequested) return;

                        bool needStart = cam.Proc == null;
                        if (!needStart)
                        {
                            try
                            {
                                if (cam.Proc.HasExited) needStart = true;
                            }
                            catch
                            {
                                needStart = true;
                            }
                        }

                        if (!needStart) continue;

                        // Too many failures recently -> pause this camera
                        if (cam.FailCount >= 5 &&
                            (DateTime.UtcNow - cam.LastFailUtc) < TimeSpan.FromMinutes(10))
                        {
                            cam.NextAllowedStartUtc = DateTime.UtcNow.AddMinutes(10);
                            UpsertRow(cam, null, "Disabled (Too many errors)", cam.LastErrorLine, updateStartTime: false);
                            continue;
                        }

                        StartCamera(cam, "watchdog");
                    }
                }
                finally
                {
                    _watchdogBusy = false;
                }
            });
        }

        // ============================
        // Maintenance
        // ============================
        private void MaintenanceTimer_Tick(object sender, EventArgs e)
        {
            if (_maintenanceBusy) return;
            _maintenanceBusy = true;

            ThreadPool.QueueUserWorkItem(_ =>
            {
                try
                {
                    CleanupOldRecordings();
                    CleanupOldLogs();
                }
                finally
                {
                    _maintenanceBusy = false;
                }
            });
        }

        private void CleanupOldRecordings()
        {
            try
            {
                if (!Directory.Exists(_recordingRoot)) return;

                var cutoff = DateTime.Now.AddDays(-_retentionDays);

                foreach (var file in Directory.GetFiles(_recordingRoot, "*.*", SearchOption.AllDirectories))
                {
                    try
                    {
                        string ext = Path.GetExtension(file).ToLowerInvariant();
                        if (ext != ".mp4" && ext != ".mkv" && ext != ".avi")
                            continue;

                        var info = new FileInfo(file);
                        if (info.LastWriteTime < cutoff)
                            info.Delete();
                    }
                    catch
                    {
                    }
                }
            }
            catch (Exception ex)
            {
                LogLine("CleanupOldRecordings failed: " + ex.Message);
            }
        }

        private void CleanupOldLogs()
        {
            try
            {
                if (!Directory.Exists(_logRoot)) return;

                var cutoff = DateTime.Now.AddDays(-_logRetentionDays);

                foreach (var file in Directory.GetFiles(_logRoot, "*.*", SearchOption.TopDirectoryOnly))
                {
                    try
                    {
                        var info = new FileInfo(file);
                        if (info.LastWriteTime < cutoff)
                            info.Delete();
                    }
                    catch
                    {
                    }
                }
            }
            catch (Exception ex)
            {
                LogLine("CleanupOldLogs failed: " + ex.Message);
            }
        }

        // ============================
        // UI handlers
        // ============================
        private void btnStartRecording_Click(object sender, EventArgs e)
        {
            if (!_configOk || _cameras.Count == 0)
            {
                MessageBox.Show(
                    "Configuration is invalid or no cameras are loaded.\nFix nvrsettings.json and restart.",
                    "Error",
                    MessageBoxButtons.OK,
                    MessageBoxIcon.Error);
                return;
            }

            _stopRequested = false;

            btnStartRecording.Enabled = false;
            btnStopRecordings.Enabled = true;
            btnCloseApplication.Enabled = false;
            btnUpdateSettings.Enabled = false;

            _rows.Clear();
            foreach (var cam in _cameras)
            {
                UpsertRow(cam, null, "Starting", "", updateStartTime: false);
            }

            // Start all cameras once
            foreach (var cam in _cameras)
            {
                StartCamera(cam, "manual");
            }

            _watchdogTimer.Start();
            _maintenanceTimer.Start();
        }

        private void btnStopRecordings_Click(object sender, EventArgs e)
        {
            _stopRequested = true;

            _watchdogTimer.Stop();
            _maintenanceTimer.Stop();

            foreach (var cam in _cameras)
            {
                StopCamera(cam);
                UpsertRow(cam, null, "Stopped", cam.LastErrorLine, updateStartTime: false);
            }

            btnStartRecording.Enabled = true;
            btnStopRecordings.Enabled = false;
            btnCloseApplication.Enabled = true;
            btnUpdateSettings.Enabled = true;
        }

        private void btnCloseApplication_Click(object sender, EventArgs e)
        {
            Application.Exit();
        }

        private void btnUpdateCameraTime_Click(object sender, EventArgs e)
        {
            // Optional – placeholder
            LogLine("Update Camera Time clicked.");
            MessageBox.Show(
                "Update Camera Time is optional.\n" +
                "You can implement it later via ONVIF or vendor HTTP API.",
                "Not Implemented",
                MessageBoxButtons.OK,
                MessageBoxIcon.Information);
        }

        private void btnUpdateSettings_Click(object sender, EventArgs e)
        {
            try
            {
                frmSettings settingsForm = new frmSettings();
                settingsForm.ShowDialog(this);

            }
            catch (Exception ex)
            {
                MessageBox.Show(ex.Message, "Error", MessageBoxButtons.OK, MessageBoxIcon.Error);
                LogLine("btnUpdateSettings_Click error: " + ex.Message);
            }
        }

        private void btnManageCameras_Click(object sender, EventArgs e)
        {
            // For now, reuse the same JSON editor
            btnUpdateSettings_Click(sender, e);
        }

        private void ReloadConfiguration()
        {
            // Stop if running
            _stopRequested = true;
            try { _watchdogTimer?.Stop(); } catch { }
            try { _maintenanceTimer?.Stop(); } catch { }

            foreach (var cam in _cameras)
            {
                StopCamera(cam);
            }

            _cameras.Clear();
            _rows.Clear();

            _configOk = false;
            _jsonErrorAlreadyShown = false; // allow showing if broken
            LoadSettingsOrExitOnce();
            if (!_configOk) return;

            foreach (var cam in _cameras)
            {
                UpsertRow(cam, null, "Stopped", "", updateStartTime: false);
            }

            LogLine("Configuration reloaded from JSON.");
        }
    }
}
